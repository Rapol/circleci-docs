---
contentTags:
  platform:
  - Cloud
  - Server v4.x
  - Server v3.x
---
= Using workflows to orchestrate jobs
:page-description: Learn about using CircleCI workflows to orchestrate jobs
:page-layout: classic-docs
:page-liquid:
:icons: font
:experimental:

Workflows in CircleCI are used to orchestrate jobs, with options to control run order, scheduling, and access to resources. This page explains how to configure workflows to suit your project. Optimizing your workflow configuration can increase the speed of your software development through faster feedback, shorter reruns, and more efficient use of resources.

[#overview]
== Overview

A *workflow* is a set of rules for defining a collection of jobs and their run order. Workflows support complex job orchestration using a set of configuration keys:

With workflows, you can:

* Run and troubleshoot jobs independently with real-time status feedback.
* Schedule workflows for jobs that should only run periodically.
* Fan-out to run multiple jobs concurrently for efficient version testing.
* Fan-in to deploy to multiple platforms.

For example, if only one job in a workflow fails, you will know it is failing in real-time. Instead of wasting time waiting for the entire workflow to fail and rerunning the entire job set, you can rerun _just the failed job_.

[#states]
=== States

Workflows may have one of the following states:

[.table.table-striped]
[cols=3*, options="header", stripes=even]
|===
| State | Description | Terminal state

| RUNNING
| Workflow is in progress
| No

| NOT RUN
| Workflow never started
| Yes

| CANCELED
| Workflow canceled before it finished
| Yes

| FAILING
| A job in the workflow failed, but others are still running or yet to be approved
| No

| FAILED
| One or more jobs in the workflow failed
| Yes

| SUCCESS
| All jobs in the workflow completed successfully
| Yes

| NEEDS APPROVAL (UI) / ON HOLD
| A job in the workflow is waiting for approval
| No

| ERROR
| We experienced an internal error starting a job in the workflow
| Yes

| UNAUTHORIZED
| One or more of the jobs terminated with a `unauthorized` job status. The triggering account does not have access to a required restricted context.
| Yes
|===

NOTE: After 90 days non-terminal workflows are automatically by CircleCI.

[#workflows-configuration-examples]
== Workflows configuration examples

TIP: For a full specification of the `workflows` key, see the xref:configuration-reference#workflows[Workflows] section of the configuration reference.

[#concurrent-job-execution]
=== Concurrent job execution

The following example configuration file shows the default workflow orchestration of two concurrent jobs. Concurrent jobs are defined as follows:

* Use the `workflows` key.
* Name the workflow, in this case, `build_and_test`.
* Nest the `jobs` key with a list of job names that are defined in the configuration file. In this example the jobs have no dependencies defined, so they run concurrently.

{% include snippets/docker-auth.adoc %}

[source,yaml]
----
jobs:
  build:
    docker:
      - image: cimg/base:2023.06
    steps:
      - checkout
      - run: <command>
  test:
    docker:
      - image: cimg/base:2023.06
    steps:
      - checkout
      - run: <command>
workflows:
  build_and_test:
    jobs:
      - build
      - test
----

See the link:https://github.com/CircleCI-Public/circleci-demo-workflows/blob/parallel-jobs/.circleci/config.yml[Sample concurrent workflow config] for a full example.

When using workflows, note the following best practices:

* Move the quickest jobs up to the start of your workflow. For example, lint or syntax checking should happen before longer-running, more computationally expensive jobs.
* If relevant, use a "setup" job at the _start_ of a workflow can be helpful to do some preflight checks and populate a workspace for all the following jobs.

Refer to the xref:optimizations#[Optimization reference] for more tips to improve your configuration.

[#sequential-job-execution]
=== Sequential job execution

The following example shows a workflow with four sequential jobs. The jobs run as configured, each job waiting to start until the required job finishes successfully, as illustrated in the diagram.

image::/docs/assets/img/docs/sequential_workflow.png[Sequential Job Execution Workflow]

The following configuration snippet is an example of a workflow configured for sequential job execution:

[source,yaml]
----
workflows:
  build-test-and-deploy:
    jobs:
      - build
      - test1:
          requires:
            - build
      - test2:
          requires:
            - test1
      - deploy:
          requires:
            - test2
----

Define job dependencies using the `requires` key. A job must wait until all upstream jobs in the dependency graph have run. In this example, the `deploy` job will not run until the `build`, `test1` and `test2` jobs complete successfully:

* The `deploy` job waits for the `test2` job
* The `test2` job waits for the `test1` job
* The `test1` job waits for the `build` job

See the link:https://github.com/CircleCI-Public/circleci-demo-workflows/blob/sequential-branch-filter/.circleci/config.yml[Sample Sequential Workflow config] for a full example.

[#fan-outfan-in-workflow]
=== Fan-out/fan-in workflow

The example workflow in the illustration below has a fan-out/fan-in structure, as follows:

* A common build job is run.
* The workflow fans-out to run a set of acceptance test jobs concurrently.
* The workflow fans-in to run a common deploy job.

image::/docs/assets/img/docs/fan-out-in.png[Fan-out and Fan-in Workflow]

The following configuration snippet is an example of a workflow configured for fan-out/fan-in job execution:

[source,yaml]
----
workflows:
  build_accept_deploy:
    jobs:
      - build
      - acceptance_test_1:
          requires:
            - build
      - acceptance_test_2:
          requires:
            - build
      - acceptance_test_3:
          requires:
            - build
      - acceptance_test_4:
          requires:
            - build
      - deploy:
          requires:
            - acceptance_test_1
            - acceptance_test_2
            - acceptance_test_3
            - acceptance_test_4
----

In this example, as soon as the `build` job finishes successfully, all four acceptance test jobs start. The `deploy` job must wait for all four acceptance test jobs to complete successfully before it starts.

See the link:https://github.com/CircleCI-Public/circleci-demo-workflows/tree/fan-in-fan-out[Sample Fan-in/Fan-out Workflow config] for a full example.

[#holding-a-workflow-for-a-manual-approval]
== Hold a workflow for a manual approval

Use an `approval` job to configure a workflow to wait for manual approval before continuing. Anyone who has push access to the repository can approve the job to continue the workflow. Approve either by using the *Approve* button in the CircleCI web app, or via the API.

To set up a manual approval workflow, add a job to the `jobs` list in your workflow with `type: approval`. For example:

[source,yaml]
----
# ...
# << your config for the build, test1, test2, and deploy jobs >>
# ...

workflows:
  build-test-and-approval-deploy:
    jobs:
      - build  # your custom job from your config, that builds your code
      - test1: # your custom job; runs test suite 1
          requires: # test1 will not run until the `build` job is completed.
            - build
      - test2: # another custom job; runs test suite 2,
          requires: # test2 is dependent on the success of job `test1`
            - test1
      - hold: # <<< A job that will require manual approval in the CircleCI web application.
          type: approval # This key-value pair will set your workflow to a status of "Needs Approval"
          requires: # We only run the "hold" job when test2 has succeeded
           - test2
      # On approval of the `hold` job, any successive job that requires the `hold` job will run.
      # In this case, a user is manually triggering the deploy job.
      - deploy:
          requires:
            - hold
----

In this example, the `deploy` job will not run until the `hold` job is approved. To approve a job follow these steps:

[.tab.approve.CircleCI_web_app]
--
. Select the `hold` job in the *Workflows* page of the CircleCI web app.
. Select btn:[Approve].
--

[.tab.approve.API]
--
. Use the workflow

--

In this example, the purpose of the `hold` job is to wait for approval to begin deployment. A job can be approved for up to 90 days after it starts.

Some things to keep in mind when using manual approval in a workflow:

* `approval` is a special job type that is *only* available to jobs under the `workflow` key.
* The `hold` job must be a unique name not used by any other job. That is, your custom configured jobs, such as `build` or `test1` in the example above would not be configured as `type: approval`.
* The name of the approval job is arbitrary. For example, an approval job can be named `wait` or `pause`.
* All jobs you want to run _after_ a manual approval job _must_ `require` the name of the approval job.
* Jobs run in the order defined in the workflow. When the workflow encounters a job with `type: approval`, the workflow pauses until approval is granted. One approval is granted the workflow continues to process jobs in the order defined in the configuration file.

The following screenshot demonstrates a workflow that needs approval, the approval popup, and the resulting workflow map once approved.

image::/docs/assets/img/docs/approval-workflow-map.png[A three section image showing workflow map with "Needs approval" job, the approval popup, and the resulting workflow map]

By clicking on the approval job's name (`hold`, in the screenshot above), an approval dialog box appears requesting that you approve the approval job. You can also choose to close the popup without approving.

After approving, the rest of the workflow runs as configured.

[#scheduling-a-workflow]
== Scheduling a workflow

NOTE: *The deprecation of the scheduled workflows feature is postponed*. Since the deprecation announcement went live, your feedback and feature requests have been monitored and it is clear there is more work for us to do to improve the existing scheduled pipelines experience, and also make migration easier for all. Updates on a new deprecation timeline will be announced here and on link:https://discuss.circleci.com/[CircleCI Discuss].

By default, a workflow runs on every `git push`. To trigger a workflow on a schedule, add the `triggers` key to the workflow and specify a `schedule`.

Running a workflow for every commit for every branch can be inefficient and expensive. Scheduling a workflow is an alternative to building on every commit. You can _schedule_ a workflow to run at a certain time for a specific branch or branches.

A scheduled workflow will run on a schedule only. A scheduled workflow will **not** be run on commits to your code.

Consider scheduling workflows that are resource-intensive or that generate reports on a schedule rather than on every commit. Schedule a workflow by adding a `triggers` key to the workflow configuration. The `triggers` key is *only* added under the `workflows` key. Scheduled workflows use the `cron` syntax to represent Coordinated Universal Time (UTC).

If you do not configure any workflows in your `.circleci/config.yml`, an implicit workflow is used. If you declare a workflow to run a scheduled build, the implicit workflow is no longer run. You must add your workflow to your `config.yml` in order for CircleCI to also build on every commit.

NOTE: When you schedule a workflow, the workflow will be counted as an individual user seat.

[#nightly-example]
=== Nightly example

In the example below, the `nightly` workflow is configured to run every day at 12:00am UTC. The `cron` key is specified using POSIX `crontab` syntax, see the link:https://www.unix.com/man-page/POSIX/1posix/crontab/[crontab man page] for `cron` syntax basics. The workflow will be run on the `main` and `beta` branches.

NOTE: Scheduled workflows may be delayed by up to 15 minutes. This delay is to maintain reliability during busy times such as 12:00am UTC. Do not assume that scheduled workflows start with to-the-minute accuracy.

[source,yaml]
----
workflows:
  commit:
    jobs:
      - test
      - deploy
  nightly:
    triggers:
      - schedule:
          cron: "0 0 * * *"
          filters:
            branches:
              only:
                - main
                - beta
    jobs:
      - coverage
----

In the above example, the `commit` workflow has no `triggers` key and runs on every `git push`. The `nightly` workflow has a `triggers` key and runs on the specified `schedule`.

[#specifying-a-valid-schedule]
=== Specifying a valid schedule

A valid `schedule` requires a `cron` key and a `filters` key.

The value of the `cron` key must be a link:https://crontab.guru/[valid crontab entry].

The following are *not* supported:

* Cron step syntax (for example, `*/1`, `*/20`).
* Range elements within comma-separated lists of elements.
* Range elements for days (for example, `Tue-Sat`).

Use comma-separated digits instead.

Example *invalid* cron range syntax:

[source,yaml]
----
    triggers:
      - schedule:
          cron: "5 4 * * 1,3-5,6" # < the range separator with `-` is invalid
----

Example *valid* cron range syntax:

[source,yaml]
----
    triggers:
      - schedule:
          cron: "5 4 * * 1,3,4,5,6"
----

The value of the `filters` key must be a map that defines rules for execution on specific branches.

For more details, see the `branches` section of the xref:configuration-reference#branches-1[CircleCI configuration reference].

For a full configuration example, see the link:https://github.com/CircleCI-Public/circleci-demo-workflows/blob/try-schedule-workflow/.circleci/config.yml[Sample Scheduled Workflows configuration].

[#using-job-contexts-to-share-environment-variables]
== Using contexts to share and secure environment variables

In a workflow, you can use a context to securely provide environment variables to specific jobs.
Contexts allow you to define environment variables at the organization level and control access to them through security restrictions.
Using contexts, sensitive data like API keys or credentials are securely shared with only the jobs that require them. Sensitive data in contexts will not be exposed in your config file.

The following example shows a workflow with four sequential jobs that each use a context to access environment variables. See the xref:contexts#[Contexts] page for detailed instructions on this setting in the application. Contexts are used to store environment variables at an organization level, and can be configured with restrictions to control access.

The following `config.yml` snippet is an example of a sequential job workflow configured to use the resources defined in the `org-global` context:

[source,yaml]
----
workflows:
  build-test-and-deploy:
    jobs:
      - build
      - test1:
          requires:
            - build
          context: org-global
      - test2:
          requires:
            - test1
          context: org-global
      - deploy:
          requires:
            - test2
----

Environment variable access is configured by setting the `context` key as shown. In this example a context called `org-global` is used.

The `test1` and `test2` jobs have access to environment variables stored in the `org-global` context if the pipeline meets the restrictions set for the context, for example:

* Was the pipeline triggered by a user who xref:contexts#security-goup-restrictions[has access] (is in the relevant org/security group etc.)?
* Does the xref:contexts#project-restrictions[project have access] to the context? By default all projects in an organization have access to contexts set for that organization, but restrictions on project access can be configured.
* Does the pipeline meet the requirements of any xref:contexts#expression-restrictions[expression restrictions] set up for the context?

== Use conditional logic in workflows

#TODO#

[#using-filters-in-your-workflows]
== Using filters in your workflows

The following sections provide example for using Contexts and filters to manage job execution.

[#branch-level-job-execution]
=== Branch-level job execution

The following example shows a workflow configured to run specific sets of jobs on three separate branches: `dev`, `stage`, and `pre-prod`.

NOTE: Workflows ignore `branches` keys nested under `jobs` configuration. If you use the deprecated job-level branches key, remove the job-level branching and instead declare it in the workflows section of your `.circleci/config.yml`.

image::/docs/assets/img/docs/branch_level.png[Branch-Level Job Execution]

The following `.circleci/config.yml` snippet is an example of a workflow configured for branch-level job execution:

[source,yaml]
----
workflows:
  dev_stage_pre-prod:
    jobs:
      - test_dev:
          filters:  # using regex filters requires the entire branch to match
            branches:
              only:  # only branches matching the below regex filters will run
                - dev
                - /user-.*/
      - test_stage:
          filters:
            branches:
              only: stage
      - test_pre-prod:
          filters:
            branches:
              only: /pre-prod(?:-.+)?$/
----

For more information on regular expressions, see the <<using-regular-expressions-to-filter-tags-and-branches,Using Regular Expressions to Filter Tags And Branches>> section below.

For a full example of workflows, see the link:https://github.com/CircleCI-Public/circleci-demo-workflows/blob/sequential-branch-filter/.circleci/config.yml[configuration file] for the Sample Sequential Workflow With Branching project.

[#executing-workflows-for-a-git-tag]
=== Executing workflows for a git tag

CircleCI does not run workflows for tags unless you explicitly specify tag filters. Both lightweight and annotated tags are supported.

If you have configured a job to run on a git tag you must also specify tag filters for any dependent jobs. Use <<using-regular-expressions-to-filter-tags-and-branches,regular expressions>> to specify tag filters for a job.

In the example below, two workflows are defined:

* `untagged-build` runs the `build` job for all branches.
* `tagged-build` runs `build` for all branches *and* all tags starting with `v`.

[source,yaml]
----
workflows:
  untagged-build:
    jobs:
      - build
  tagged-build:
    jobs:
      - build:
          filters:
            tags:
              only: /^v.*/
----

In the example below, two jobs are defined within the `build-n-deploy` workflow:

* The `build` job runs for all branches and all tags.
* The `deploy` job runs for no branches and only for tags starting with 'v'.

[source,yaml]
----
workflows:
  build-n-deploy:
    jobs:
      - build:
          filters:  # required since `deploy` has tag filters AND requires `build`
            tags:
              only: /.*/
      - deploy:
          requires:
            - build
          filters:
            tags:
              only: /^v.*/
            branches:
              ignore: /.*/
----

In the example below, three jobs are defined with the `build-test-deploy` workflow:

* The `build` job runs for all branches and only tags starting with 'config-test'.
* The `test` job runs for all branches and only tags starting with 'config-test'.
* The `deploy` job runs for no branches and only tags starting with 'config-test'.

[source,yaml]
----
workflows:
  build-test-deploy:
    jobs:
      - build:
          filters:  # required since `test` has tag filters AND requires `build`
            tags:
              only: /^config-test.*/
      - test:
          requires:
            - build
          filters:  # required since `deploy` has tag filters AND requires `test`
            tags:
              only: /^config-test.*/
      - deploy:
          requires:
            - test
          filters:
            tags:
              only: /^config-test.*/
            branches:
              ignore: /.*/
----

In the example below, two jobs are defined (`test` and `deploy`) and three workflows utilize those jobs:

* The `build` workflow runs for all branches except `main` and is not run on tags.
* The `staging` workflow will only run on the `main` branch and is not run on tags.
* The `production` workflow runs for no branches and only for tags starting with `v.`.

[source,yaml]
----
workflows:
  build: # This workflow will run on all branches except 'main' and will not run on tags
    jobs:
      - test:
          filters:
            branches:
              ignore: main
  staging: # This workflow will only run on 'main' and will not run on tags
    jobs:
      - test:
          filters: &filters-staging # this yaml anchor is setting these values to "filters-staging"
            branches:
              only: main
            tags:
              ignore: /.*/
      - deploy:
          requires:
            - test
          filters:
            <<: *filters-staging # this is calling the previously set yaml anchor
  production: # This workflow will only run on tags (specifically starting with 'v.') and will not run on branches
    jobs:
      - test:
          filters: &filters-production # this yaml anchor is setting these values to "filters-production"
            branches:
              ignore: /.*/
            tags:
              only: /^v.*/
      - deploy:
          requires:
            - test
          filters:
            <<: *filters-production # this is calling the previously set yaml anchor
----

NOTE: Webhook payloads are capped at 25 MB and for some events a maximum of 3 tags. If you push several tags at once, CircleCI may not receive them all.

[#using-regular-expressions-to-filter-tags-and-branches]
=== Using regular expressions to filter tags and branches

CircleCI branch and tag filters support the Java variant of regex pattern matching. When writing filters, CircleCI matches exact regular expressions.

For example, `+only: /^config-test/+` only matches the `config-test` tag. To match all tags starting with `config-test`, use `+only: /^config-test.*/+` instead.

Using tags for semantic versioning is a common use case. To match patch versions 3-7 of a 2.1 release, you can write `+/^version-2\.1\.[3-7]/+`.

For full details on pattern-matching rules, see the link:https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html[`java.util.regex` documentation].

[#using-workspaces-to-share-data-between-jobs]
== Using workspaces to share data between jobs

Each workflow has an associated workspace which can be used to transfer files to downstream jobs as the workflow progresses. For further information on workspaces and their configuration see the xref:workspaces#[Using Workspaces to Share Data Between Jobs] doc.

[#rerunning-a-workflows-failed-jobs]
== Rerunning a workflow's failed jobs

You can configure workflows to speed up your ability to respond to failures. To rerun only a workflow's _failed_ jobs, follow these steps:

. In the CircleCI web app select **Pipelines** in the sidebar
. Use the filters to find your pipeline
. Find the row in the pipeline view for the workflow you would like to rerun from failed and select the *Rerun from failed* icon. This option is also available in the workflow view using the rerun dropdown menu, which you can access by clicking on the workflow name or badge.

[tab.rerun-screenshot.Rerun_from_the_pipelines_page]
--
image::/docs/assets/img/docs/orchestrate-and-trigger/rerun-from-failed-pipelines-page.png[Rerun a workflow from failed from the pipelines page]
--

[tab.rerun-screenshot.Rerun_from_the_workflows_page]
--
image::/docs/assets/img/docs/orchestrate-and-trigger/rerun-from-failed-workflows-page.png[Rerun a workflow from failed from the workflows page]
--

NOTE: If you rerun a workflow that contains a job which was previously re-run with SSH, the new workflow runs with SSH enabled for that job, even after SSH capability is disabled at the project level.

[#troubleshooting]
== Troubleshooting

This section describes common problems and solutions for workflows.

[#workflow-and-subsequent-jobs-do-not-trigger]
=== Workflow and subsequent jobs do not trigger

If you do not see your workflows trigger, a common cause is a configuration error preventing the workflow from starting. As a result, the workflow does not start any jobs. Navigate to your project's pipelines and select your workflow name to locate the failure.

[#rerunning-workflows-fails]
=== Rerunning workflows fails

In some cases, a failure may happen before the workflow runs (during pipeline processing). Re-running the workflow will fail even though it succeeded before the outage. To work around this, push a change to the project's repository. This will rerun the pipeline processing first, and then rerun the workflow.

NOTE: You cannot rerun jobs and workflows that are >= 90 days.

[#workflows-waiting-for-status-in-github]
=== Workflows waiting for status in GitHub

If you have workflows configured on a protected branch and the status check never completes, check the `ci/circleci` status key. `ci/circleci` should be and deselected as it is related to a deprecated check.

image::/docs/assets/img/docs/github_branches_status.png[Uncheck GitHub Status Keys]

Go to menu:Settings[Branches] in GitHub and select btn:[Edit] on the protected branch to deselect the settings, for example: `\https://github.com/your-org/project/settings/branches`.

[#see-also]
== See also

* See the xref:faq#workflows[workflows] section of the FAQ.
* For workflow configuration examples, see the link:https://github.com/CircleCI-Public/circleci-demo-workflows[CircleCI Demo Workflows] page on GitHub.
